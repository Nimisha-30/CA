# -*- coding: utf-8 -*-
"""PS8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iRxeh5I3ShHJjGiNt6oyiqfqA2fhfjCz
"""

import numpy as np
import matplotlib.pyplot as plt

"""# Problem 1

Consider the sequence “AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT”.
Create a dot matrix plot of the sequence against itself. Use a window size of 4 and a threshold of 3.
Modify the dot matrix analysis to check for inverted repeats by comparing the sequence with its reverse complement.
Use a window size of 5 and a threshold of 4.
"""

sequence="AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
window1=4
threshold1=3
window2=5
threshold2=4

# Function to create dot matrix plot of sequence against itself
def dotMatrix(seq1, seq2, window_size, threshold):
    n1, n2=len(seq1), len(seq2)
    matrix=np.zeros((n1, n2))
    for i in range(n1-window_size+1):
        for j in range(n2-window_size+1):
            match_count=sum(1 for k in range(window_size) if seq1[i+k]==seq2[j+k])
            if match_count>=threshold:
                matrix[i][j]=1
    return matrix

dotmatrix=dotMatrix(sequence, sequence, window1, threshold1)

# Function to find reverse complement
def reverseComplement(seq):
    complement={'A':'T', 'T':'A', 'C':'G', 'G':'C'}
    return ''.join([complement[base] for base in seq[::-1]])

rev_comp_seq=reverseComplement(sequence)
rev_dot_matrix=dotMatrix(sequence, rev_comp_seq, window2, threshold2)

# Plotting the results
fig, (ax1, ax2)=plt.subplots(1, 2, figsize=(12, 6))

# Sequence vs Sequence
ax1.imshow(dotmatrix, cmap='cool', origin='lower')
ax1.set_title('Dot Matrix: Sequence vs Sequence')
ax1.set_xlabel('Sequence')
ax1.set_ylabel('Sequence')

# Sequence vs Reverse Complement
ax2.imshow(rev_dot_matrix, cmap='cool', origin='lower')
ax2.set_title('Dot Matrix: Sequence vs Reverse Complement')
ax2.set_xlabel('Sequence')
ax2.set_ylabel('Reverse Complement')

plt.tight_layout()
plt.show()

"""# Problem 2

Consider genomic sequence of a species.
Perform a self-comparison dot matrix analysis by comparing the sequence with itself and its reverse complement.
Implement a mechanism to detect palindromes and inverted repeats, where matches between the sequence and its reverse complement form off-diagonal patterns.
Visualize the dot matrix and annotate significant palindromic sequences and inverted repeats.
Filter out short random matches and focus on palindromes and repeats that are at least 10 base pairs in length.
"""

# genomic sequence
genomic_sequence = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCTTGCATGCCTAGGCTAACGTT"
window_size=10
threshold=9

# Function to detect palindromes and inverted repeats in a dot matrix
def detect_palindromes_inverted_repeats(seq1, seq2, window, threshold):
    n1, n2=len(seq1), len(seq2)
    matrix=np.zeros((n1, n2))
    palindromes=[]
    for i in range(n1-window+1):
        for j in range(n2-window+1):
            matchcount=sum(1 for k in range(window) if seq1[i+k]==seq2[j+k])
            if matchcount>=threshold:
                matrix[i][j]=1
                if abs(i-j)>=10:
                    palindromes.append((i, j, window))
    return matrix, palindromes

dotmatrix, palindromes=detect_palindromes_inverted_repeats(genomic_sequence, genomic_sequence, window_size, threshold)

# Function to find reverse complement sequence
def reverse_complement(seq):
    complement={'A':'T', 'T':'A', 'C':'G', 'G':'C'}
    return ''.join([complement[base] for base in seq[::-1]])

rev_comp_seq=reverse_complement(genomic_sequence)
rev_dot_matrix, rev_palindromes=detect_palindromes_inverted_repeats(genomic_sequence, rev_comp_seq, window_size, threshold)

# Plotting the results
fig, (ax1, ax2)=plt.subplots(1, 2, figsize=(12, 6))

# Sequence vs sequence
ax1.imshow(dotmatrix, cmap='cool')
ax1.set_title('Dot Matrix: Sequence vs Sequence')
ax1.set_xlabel('Sequence')
ax1.set_ylabel('Sequence')

# Highlight significant palindromes
for i, j, length in palindromes:
    ax1.plot([j, j+length], [i, i+length], color='red', lw=2)

# Sequence vs reverse sequence complement
ax2.imshow(rev_dot_matrix, cmap='cool')
ax2.set_title('Reverse Dot Matrix: Sequence vs Reverse Complement')
ax2.set_xlabel('Sequence')
ax2.set_ylabel('Reverse Complement Sequence')

# Highlight significant inverted repeats
for i, j, length in rev_palindromes:
    ax2.plot([j, j+length], [i, i+length], color='red', lw=2)

plt.tight_layout()
plt.show()

"""# Problem 3

Consider two protein sequences.
Compare the two protein sequences using a window size of 10 and a threshold of 8.
Implement a time-efficient algorithm to compute the dot matrix, focusing on improving the performance for large sequences.
Compare your algorithm with the naive O(n2) approach in terms of time complexity and runtime.
"""

def naive_dot_matrix(seq1, seq2, window_size, threshold):
    n1, n2=len(seq1), len(seq2)
    matrix=np.zeros((n1, n2))
    for i in range(n1-window_size+1):
        for j in range(n2-window_size+1):
            matchcount=sum(1 for k in range(window_size) if seq1[i+1]==seq2[j+k])
            if matchcount>=threshold:
                matrix[i][j]=1
    return matrix

def efficient_dot_matrix(seq1, seq2, window_size, threshold):
    n1, n2=len(seq1), len(seq2)
    matrix=np.zeros((n1, n2))
    # Precompute window match counts for efficiency
    window_match_counts=np.zeros((n1-window_size+1, n2-window_size+1))
    for k in range(window_size):
        for i in range(n1-window_size+1):
            for j in range(n2-window_size+1):
                if seq1[i+k]==seq2[j+k]:
                    window_match_counts[i][j]+=1
    # Fill matrix based on threshold
    for i in range(n1-window_size+1):
        for j in range(n2-window_size+1):
            if window_match_counts[i][j]>=threshold:
                matrix[i][j]=1
    return matrix

# Example protein sequences
protein_seq1 = "MVLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASEDLKKHGTVVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHPGNFGADAQGAM"
protein_seq2 = "MGLSDGEWQLVLNVWGKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASEDLKKHGTVVLTALGAILKKKGQHEAELKPLAQSHATKHKIPVKYLEFISEAIIHVLHSRHPGNFGADAQGAM"

# Parameters for dot matrix
window_size_protein = 10
threshold_protein = 8

import time

# Measure runtime for naive approach
start_naive = time.time()
naive_matrix = naive_dot_matrix(protein_seq1, protein_seq2, window_size_protein, threshold_protein)
end_naive = time.time()

# Measure runtime for efficient approach
start_efficient = time.time()
efficient_matrix = efficient_dot_matrix(protein_seq1, protein_seq2, window_size_protein, threshold_protein)
end_efficient = time.time()

# Compare runtime
naive_time = end_naive - start_naive
efficient_time = end_efficient - start_efficient

naive_time, efficient_time

"""# Problem 4

Implement a dot matrix algorithm to compare each pair of sequences (i.e., Sequence1 vs. Sequence2, Sequence1 vs. Sequence3, and Sequence2 vs. Sequence3). Use a fixed window size of 15 nucleotides for comparison.
For each pairwise comparison, identify and extract regions of significant similarity. Define a conserved region as a region that is significantly matched in all pairwise comparisons.
Create a combined dot matrix visualization that highlights regions conserved across all sequences. Overlay this with annotations to show the conserved regions.
Plot individual dot matrices for each pairwise comparison and compare them with the combined visualization.
"""

# Example sequences (3 sequences for pairwise comparison)
sequence1 = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
sequence2 = "AGCTTAGCTGGGCTAAACGGATCGGTTTAGCTTAACTTAGGCT"
sequence3 = "AGCTTCGATCGGCTAATCGGACCGGTTTAGCGTAGCTTAGGCT"

# Parameters
window_size = 15
threshold = 12  # Require at least 12 out of 15 nucleotides to match

# Compute pairwise dot matrices
matrix1_vs_2 = dotMatrix(sequence1, sequence2, window_size, threshold)
matrix1_vs_3 = dotMatrix(sequence1, sequence3, window_size, threshold)
matrix2_vs_3 = dotMatrix(sequence2, sequence3, window_size, threshold)

# Function to extract conserved regions across all pairwise comparisons
def find_conserved_regions(matrix1, matrix2, matrix3):
    combinedmatrix=matrix1*matrix2*matrix3
    return combinedmatrix

# Find conserved regions (regions that are matched in all pairwise comparisons)
conserved_matrix = find_conserved_regions(matrix1_vs_2, matrix1_vs_3, matrix2_vs_3)

# Plot function for all individual and combined matrices
def plot_dot_matrices(seq1, seq2, seq3, mat1, mat2, mat3, combinedmat):
    fig, axes=plt.subplots(2, 2, figsize=(10, 10))
    axes[0, 0].imshow(mat1, cmap='cool', origin='lower')
    axes[0, 0].set_title(f"Dot Matrix: {seq1} or {seq2}")
    axes[0, 1].imshow(mat2, cmap='cool', origin='lower')
    axes[0, 1].set_title(f"Dot Matrix: {seq1} or {seq3}")
    axes[1, 0].imshow(mat3, cmap='cool', origin='lower')
    axes[1, 0].set_title(f"Dot Matrix: {seq2} or {seq3}")
    axes[1, 1].imshow(combinedmat, cmap='cool', origin='lower')
    axes[1, 1].set_title("Combined Dot Matrix")
    plt.tight_layout()
    plt.show()

# Plot the dot matrices and the combined conserved regions matrix
plot_dot_matrices("Sequence1", "Sequence2", "Sequence3", matrix1_vs_2, matrix1_vs_3, matrix2_vs_3, conserved_matrix) # Corrected the order of arguments



import numpy as np
import matplotlib.pyplot as plt

# Function to compute the dot matrix between two sequences
def compute_dot_matrix(seq1, seq2, window_size, threshold):
    len1, len2 = len(seq1), len(seq2)
    matrix = np.zeros((len1, len2))
    for i in range(len1 - window_size + 1):
        for j in range(len2 - window_size + 1):
            match_count = sum(1 for k in range(window_size) if seq1[i + k] == seq2[j + k])
            if match_count >= threshold:
                matrix[i][j] = 1
    return matrix

# Function to extract conserved regions across all pairwise comparisons
def find_conserved_regions(matrix1, matrix2, matrix3):
    combined_matrix = matrix1 * matrix2 * matrix3
    return combined_matrix

# Plotting function for individual and combined matrices
def plot_dot_matrices(matrix1, matrix2, matrix3, combined_matrix, seq1, seq2, seq3):
    fig, axes = plt.subplots(2, 2, figsize=(10, 10))
    axes[0, 0].imshow(matrix1, cmap='gray_r', origin='lower')
    axes[0, 0].set_title(f"Dot Matrix: {seq1} vs {seq2}")
    axes[0, 1].imshow(matrix2, cmap='gray_r', origin='lower')
    axes[0, 1].set_title(f"Dot Matrix: {seq1} vs {seq3}")
    axes[1, 0].imshow(matrix3, cmap='gray_r', origin='lower')
    axes[1, 0].set_title(f"Dot Matrix: {seq2} vs {seq3}")
    axes[1, 1].imshow(combined_matrix, cmap='gray_r', origin='lower')
    axes[1, 1].set_title("Combined Conserved Regions")
    plt.tight_layout()
    plt.show()

# Example sequences (3 sequences for pairwise comparison)
sequence1 = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
sequence2 = "AGCTTAGCTGGGCTAAACGGATCGGTTTAGCTTAACTTAGGCT"
sequence3 = "AGCTTCGATCGGCTAATCGGACCGGTTTAGCGTAGCTTAGGCT"

# Parameters
window_size = 15
threshold = 12  # Require at least 12 out of 15 nucleotides to match

# Compute pairwise dot matrices
matrix1_vs_2 = compute_dot_matrix(sequence1, sequence2, window_size, threshold)
matrix1_vs_3 = compute_dot_matrix(sequence1, sequence3, window_size, threshold)
matrix2_vs_3 = compute_dot_matrix(sequence2, sequence3, window_size, threshold)

# Find conserved regions (regions that are matched in all pairwise comparisons)
conserved_matrix = find_conserved_regions(matrix1_vs_2, matrix1_vs_3, matrix2_vs_3)

# Plot the dot matrices and the combined conserved regions matrix
plot_dot_matrices(matrix1_vs_2, matrix1_vs_3, matrix2_vs_3, conserved_matrix, "Sequence1", "Sequence2", "Sequence3")