# -*- coding: utf-8 -*-
"""PS2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C12i8PxbnfafBJqHGvKns-dU-OTYKLC9
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from numpy.polynomial import Polynomial
from scipy.interpolate import CubicSpline, interp1d
import scipy.stats as stats
from numpy.polynomial.polynomial import Polynomial
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import yfinance as yf
from scipy.interpolate import lagrange

"""# Problem 1"""

#Read data from csv file
data = pd.read_csv("/content/Coimbatore,India 2023-01-01 to 2023-12-31.csv", usecols=['datetime', 'temp'])
data["day"] = [i for i in range(1, 366)]
print(data)

#Read data from csv file
data = pd.read_csv("weather_data.csv", usecols=['datetime', 'temp'])
data["day"] = [i for i in range(1, 366)]
print(data)

"""## Newton's Divided Difference Interpolation"""

#Newton Interplation method
#First iteration of Newton Difference Table
newton_diff_table = []
row = []
for ind in data.index:
  row.append(data['temp'][ind])
newton_diff_table.append(row)
print(newton_diff_table)

#Calculating for one value
col_ind = 1
start_ind = 0
temp = []
for i in range(0, 364):
  temp.append(round(((newton_diff_table[0][i] - newton_diff_table[0][i+1]) / (data['day'][start_ind] - data['day'][start_ind+col_ind])), 2))
  start_ind += col_ind
col_ind += 1
print(temp)
newton_diff_table.append(temp)

newton_diff_table = []
# Initialize the first column of the Newton divided difference table
newton_diff_table.append(list(data['temp']))
# Calculate the rest of the table
for col_ind in range(1, len(data)):
    temp = []
    for i in range(len(data) - col_ind):
        diff = (newton_diff_table[col_ind-1][i+1] - newton_diff_table[col_ind-1][i]) / (data['day'][i+col_ind] - data['day'][i])
        temp.append(round(diff, 2))
    newton_diff_table.append(temp)
print(newton_diff_table)

#Interpolate
def calc_prod(i, value):
  prod = 1
  for j in range(1,i):
    prod *= (value - j)
  return prod
def Interpolate(x, newton_diff_table):
  sum = 0
  for i in range(0, len(newton_diff_table)):
    sum += (newton_diff_table[i][0] * calc_prod(i,x))
    print(newton_diff_table[i][0])
    print(calc_prod(i,x))
  return sum
print(Interpolate(56, newton_diff_table))

"""## Cubic Spline Interpolation"""

# Fit a polynomial to the data
degree = 3
cubic_fit = CubicSpline(data["day"], data["temp"], bc_type='natural')

# Generate points for the polynomial curve
poly_days = np.linspace(1, 365, 1000)
cubic_temps = cubic_fit(poly_days)
#print(poly_temps)

# Generate random numbers
random_numbers = np.random.randint(1, 366, size=1000)

# Interpolate values for the random numbers
interpolated_values = cubic_fit(random_numbers)

# Plot the original data and the polynomial fit
plt.figure(figsize=(10, 5))

# Original data and polynomial fit
plt.subplot(1, 2, 1)
plt.plot(data["day"], data["temp"], 'o', label='Original Data',color="green")
plt.plot(poly_days, cubic_temps, '-', label=f'Cubic Fit', color="red")
plt.xlabel('Days')
plt.ylabel('Temperature (°C)')
plt.title('Interpolated and Cubic Spline Fit for Coimbatore Temperatures (2023)')
plt.legend()
plt.grid(True)

# Random numbers vs. interpolated values
plt.subplot(1, 2, 2)
plt.plot(random_numbers, interpolated_values, 'o', color="purple")
plt.xlabel('Random Numbers')
plt.ylabel('Interpolated Values')
plt.title('Interpolated Values vs. Random Numbers')
plt.grid(True)

plt.tight_layout()
plt.show()

t_statistic, p_value = stats.ttest_ind(data["temp"], interpolated_values)

print("T-statistic:", t_statistic)
print("P-value:", p_value)

alpha = 0.05  # Significance level

if p_value < alpha:
    print("Reject null hypothesis: There is a significant difference between the original and interpolated temperatures.")
else:
    print("Fail to reject null hypothesis: There is no significant difference between the original and interpolated temperatures.")

"""## Polynomial Interpolation"""

# Fit a polynomial to the data
degree = 3
poly_fit = Polynomial.fit(data["day"], data["temp"], deg=degree)
poly_coeffs = poly_fit.convert().coef

# Generate points for the polynomial curve
poly_days = np.linspace(1, 365, 1000)
poly_temps = poly_fit(poly_days)
#print(poly_temps)

# Generate random numbers
random_numbers = np.random.randint(1, 366, size=1000)

# Interpolate values for the random numbers
interpolated_values = poly_fit(random_numbers)

# Plot the original data and the polynomial fit
plt.figure(figsize=(10, 5))

# Original data and polynomial fit
plt.subplot(1, 2, 1)
plt.plot(data["day"], data["temp"], 'o', label='Original Data', color="green")
plt.plot(poly_days, poly_temps, '-', label=f'Polynomial Fit (degree {degree})', color="red")
plt.xlabel('Days')
plt.ylabel('Temperature (°C)')
plt.title('Interpolated and Polynomial Fit for Coimbatore Temperatures (2023)')
plt.legend()
plt.grid(True)

# Random numbers vs. interpolated values
plt.subplot(1, 2, 2)
plt.plot(random_numbers, interpolated_values, 'o', color="purple")
plt.xlabel('Random Numbers')
plt.ylabel('Interpolated Values')
plt.title('Interpolated Values vs. Random Numbers')
plt.grid(True)

plt.tight_layout()
plt.show()

t_statistic, p_value = stats.ttest_ind(data["temp"], interpolated_values)

print("T-statistic:", t_statistic)
print("P-value:", p_value)

alpha = 0.05  # Significance level

if p_value < alpha:
    print("Reject null hypothesis: There is a significant difference between the original and interpolated temperatures.")
else:
    print("Fail to reject null hypothesis: There is no significant difference between the original and interpolated temperatures.")

# Generate days for 2024
days_2024 = np.arange(1, 366)

# Interpolate temperatures for each day of 2024
temps_2024 = poly_fit(days_2024)

# Define the start and end days for each month in a non-leap year
month_days = {
    "January": (1, 31),
    "February": (32, 59),
    "March": (60, 90),
    "April": (91, 120),
    "May": (121, 151),
    "June": (152, 181),
    "July": (182, 212),
    "August": (213, 243),
    "September": (244, 273),
    "October": (274, 304),
    "November": (305, 334),
    "December": (335, 365)
}

# Calculate mean temperature for each month
mean_temps_2024 = {}
for month, (start_day, end_day) in month_days.items():
    mean_temps_2024[month] = np.mean(temps_2024[start_day-1:end_day])

# Print the mean temperatures for each month
print("Mean Temperatures for 2024:")
for month, mean_temp in mean_temps_2024.items():
    print(f"{month}: {mean_temp:.2f} °C")

# Example of original results for 2024 (replace with actual data)
original_temps_2024 = {
    "January": 21,
    "February": 24,
    "March": 28,
    "April": 33,
    "May": 38,
    "June": 35,
    "July": 32,
    "August": 30,
    "September": 28,
    "October": 26,
    "November": 24,
    "December": 22
}

for month in month_days.keys():
    original_temp = original_temps_2024[month]
    interpolated_temp = mean_temps_2024[month]
    print(f"{month}: Interpolated: {interpolated_temp:.2f} °C, Original: {original_temp} °C")

"""# Problem 2

## Polynomial Interpolation
"""

# Generate list of working days in 2023
all_days_2023 = pd.date_range(start='2023-01-01', end='2023-12-31', freq='B')
working_days_2023 = np.array([day.timetuple().tm_yday for day in all_days_2023])

# Generate 150 random working days
random_days = np.random.choice(working_days_2023, 150, replace=False)
random_days.sort()

# Download closing stock prices using yfinance
sbi_data = yf.download('SBIN.NS', start='2023-01-01', end='2023-12-31')
sbi_data['DayOfYear'] = sbi_data.index.dayofyear
closing_prices = sbi_data[['DayOfYear', 'Close']]

# Filter the closing prices for the random days
filtered_prices = closing_prices[closing_prices['DayOfYear'].isin(random_days)]

# Ensure that the DayOfYear values are sorted
filtered_prices = filtered_prices.sort_values(by='DayOfYear')

# Fit a polynomial to the data
degree = 3
x = filtered_prices['DayOfYear'].values
y = filtered_prices['Close'].values
poly_fit = Polynomial.fit(x, y, deg=degree)
poly_coeffs = poly_fit.convert().coef

# Generate predictions for ALL working days
predicted_prices_all = poly_fit(working_days_2023)

# Filter predicted prices to match available actual prices
predicted_prices = predicted_prices_all[np.isin(working_days_2023, closing_prices['DayOfYear'])]

# Plot the original data and polynomial predictions
plt.figure(figsize=(12, 6))
plt.plot(filtered_prices['DayOfYear'], filtered_prices['Close'], 'o', label='Actual Data')

# Use closing_prices['DayOfYear'] for plotting predicted values to ensure alignment
plt.plot(closing_prices['DayOfYear'], predicted_prices, 'x', label='Predicted Data')
plt.xlabel('Day of Year')
plt.ylabel('SBI Closing Stock Price')
plt.title('SBI Stock Prices: Actual and Predicted (2023)')
plt.legend()
plt.grid(True)
plt.show()

# Use all available closing prices for validation
actual_prices = closing_prices['Close'].values

# Validation - Now the lengths of actual_prices and predicted_prices should match
mae = mean_absolute_error(actual_prices, predicted_prices)
mse = mean_squared_error(actual_prices, predicted_prices)
r2 = r2_score(actual_prices, predicted_prices)

print(f'Polynomial Coefficients: {poly_coeffs}')
print(f'Mean Absolute Error (MAE): {mae:.2f}')
print(f'Mean Squared Error (MSE): {mse:.2f}')
print(f'R-squared (R²): {r2:.2f}')

"""## Cubic Spline Interpolation"""

# Generate list of working days in 2023
all_days_2023 = pd.date_range(start='2023-01-01', end='2023-12-31', freq='B')
working_days_2023 = np.array([day.timetuple().tm_yday for day in all_days_2023])

# Generate 150 random working days
random_days = np.random.choice(working_days_2023, 150, replace=False)
random_days.sort()

# Download closing stock prices using yfinance
sbi_data = yf.download('SBIN.NS', start='2023-01-01', end='2023-12-31')
sbi_data['DayOfYear'] = sbi_data.index.dayofyear
closing_prices = sbi_data[['DayOfYear', 'Close']]

# Filter the closing prices for the random days
filtered_prices = closing_prices[closing_prices['DayOfYear'].isin(random_days)]

# Ensure that the DayOfYear values are sorted
filtered_prices = filtered_prices.sort_values(by='DayOfYear')

# Fit a polynomial to the data
degree = 3
x = filtered_prices['DayOfYear'].values
y = filtered_prices['Close'].values
cubic_fit = CubicSpline(x, y, bc_type='natural')

# Generate predictions for ALL working days
predicted_prices_all = cubic_fit(working_days_2023)

# Filter predicted prices to match available actual prices
predicted_prices = predicted_prices_all[np.isin(working_days_2023, closing_prices['DayOfYear'])]

# Plot the original data and polynomial predictions
plt.figure(figsize=(12, 6))
plt.plot(filtered_prices['DayOfYear'], filtered_prices['Close'], 'o', label='Actual Data')

# Use closing_prices['DayOfYear'] for plotting predicted values to ensure alignment
plt.plot(closing_prices['DayOfYear'], predicted_prices, label='Predicted Data')
plt.xlabel('Day of Year')
plt.ylabel('SBI Closing Stock Price')
plt.title('SBI Stock Prices: Actual and Predicted (2023)')
plt.legend()
plt.grid(True)
plt.show()

# Use all available closing prices for validation
actual_prices = closing_prices['Close'].values

# Validation - Now the lengths of actual_prices and predicted_prices should match
mae = mean_absolute_error(actual_prices, predicted_prices)
mse = mean_squared_error(actual_prices, predicted_prices)
r2 = r2_score(actual_prices, predicted_prices)

print(f'Polynomial Coefficients: {poly_coeffs}')
print(f'Mean Absolute Error (MAE): {mae:.2f}')
print(f'Mean Squared Error (MSE): {mse:.2f}')
print(f'R-squared (R²): {r2:.2f}')

"""# Problem 3"""

x = [0.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,1.0]
y = [0.302,0.185,0.106,0.093,0.240,0.579,0.561,0.468,0.302]

plt.plot(x, y, 'o', label='Original Data')
plt.title('Original Data')
plt.xlabel('Time')
plt.ylabel('Apparent Magnitude')
plt.legend()
plt.show()

cs = CubicSpline(x, y,bc_type='natural')
plt.plot(x,y, 'o', label='Original Data',color='blue')
plt.plot(x, cs(x), label='Cubic Spline',color='green')
plt.title('Cubic Spline')
plt.xlabel('Time')
plt.ylabel('Apparent Magnitude')
plt.show()
print(cs.c)

random_numbers = np.random.uniform(0,1,50)
lin_space = np.linspace(0,1,50)
interpolated_values = []

for num in random_numbers:
    interpolated_value =cs(num)
    interpolated_values.append(interpolated_value)

plt.plot(lin_space, interpolated_values,color='orange')
plt.xlabel('Random Numbers')
plt.ylabel('Cubic Interpolation')
plt.show()

"""# Problem 4"""

x = [0,8,16,24,32,40]
y = [14.621,11.843,9.870,8.418,7.305,6.413]

#Generate the random numbers
#Uniform distribution
random_number_uniform  = np.random.uniform(0,40,50)
#Normal distribution with mean 20 and standard deviation 10 and size is 50
random_number_normal = np.random.normal(20,10,50)
#Exponential distribution
random_number_exponential = np.random.exponential(20.0,50)

"""## Lagrange Interpolation"""

def lagrange_interpolation(x, y, x_values):
  polynomial = lagrange(x,y)
  return polynomial(x_values)

#Uniform distribution
lagrange_uniform = lagrange_interpolation(x,y,random_number_uniform)
print("Uniform distribution")
print(lagrange_uniform)
print()

#Normal distribution
lagrange_normal = lagrange_interpolation(x,y,random_number_normal)
print("Normal distribution")
print(lagrange_normal)
print()

#Exponential distribution
lagrange_exponential = lagrange_interpolation(x,y,random_number_exponential)
print("Exponential distribution")
print(lagrange_exponential)
print()

"""## Newton's Interpolating Polynomial"""

def newton_interpolation(x, y, value):
    n = len(x)
    coefficients = np.zeros((n, n))
    coefficients[:, 0] = y

    for j in range(1, n):
        for i in range(n - j):
            coefficients[i, j] = (coefficients[i + 1, j - 1] - coefficients[i, j - 1]) / (x[i + j] - x[i])

    result = coefficients[0, 0]
    product_term = 1.0
    for i in range(1, n):
        product_term *= (value - x[i - 1])
        result += coefficients[0, i] * product_term

    return result

# Example usage:
x = np.array([0,8,16,24,32,40])
y = np.array([14.621,11.843,9.870,8.418,7.305,6.413])

#Uniform distribution
newton_uniform = newton_interpolation(x,y,random_number_uniform)
print("Uniform distribution")
print(newton_uniform)
print()

#Normal distribution
newton_normal = newton_interpolation(x,y,random_number_normal)
print("Normal distribution")
print(newton_normal)
print()

#Exponential distribution
newton_exponential = newton_interpolation(x,y,random_number_exponential)
print("Exponential distribution")
print(newton_exponential)
print()

"""## Cubic Spline Interpolation"""

cs = CubicSpline(x,y,bc_type='natural')

print("Uniform distribution")
cubic_uniform = cs(random_number_uniform)
print(cubic_uniform)
print()

print("Normal distribution")
cubic_normal = cs(random_number_normal)
print(cubic_normal)
print()

print("Exponential distribution")
cubic_exponential = cs(random_number_exponential)
print(cubic_exponential)
print()

"""## Statistical Validation"""

#Statistical Validation using coeffecient of determination
from sklearn.metrics import r2_score

print("Lagrange Interpolation")
print(r2_score(y,lagrange_interpolation(x,y,x)))

print("Newton Interpolation")
print(r2_score(y,newton_interpolation(x,y,x)))

print("Cubic Spline Interpolation")
print(r2_score(y,cs(x)))

def zScore(sample1, sample2):
  mean1 = np.mean(sample1)
  mean2 = np.mean(sample2)
  std1 = np.std(sample1)
  std2 = np.std(sample2)
  n1 = len(sample1)
  n2 = len(sample2)

  z_statistic = (mean1 - mean2)/np.sqrt((std1**2/n1) + (std2**2/n2))
  p_value = 1 - stats.norm.cdf(z_statistic)

  print("Z-statistic:", z_statistic)
  print("P-value:", p_value)

  alpha = 0.05  # Significance level

  if p_value < alpha:
    print("Reject null hypothesis: There is a significant difference between the original and interpolated values.")
  else:
    print("Fail to reject null hypothesis: There is no significant difference between the original and interpolated values.")

zScore(newton_uniform,lagrange_uniform)
zScore(newton_normal,lagrange_normal)
zScore(newton_exponential,lagrange_exponential)
zScore(cubic_uniform,lagrange_uniform)
zScore(cubic_normal,lagrange_normal)
zScore(cubic_exponential,lagrange_exponential)
zScore(newton_uniform,cubic_uniform)
zScore(newton_normal,cubic_normal)
zScore(newton_exponential,cubic_exponential)

"""# Problem 5"""

# Given data
y = np.array([0, 1, 3, 5, 7, 8, 9, 10])
H = np.array([0, 1, 1.5, 3, 3.5, 3.2, 2, 0])
U = np.array([0, 0.1, 0.12, 0.2, 0.25, 0.3, 0.15, 0])

# (a) Average Depth
average_depth = np.trapz(H, y) / (y[-1] - y[0])

# (b) Cross-Sectional Area
cross_sectional_area = np.trapz(H, y)

# (c) Average Velocity
average_velocity = np.trapz(U, y) / (y[-1] - y[0])

# (d) Flow Rate
flow_rate = cross_sectional_area * average_velocity

print(f"Average Depth: {average_depth:.2f} m")
print(f"Cross-Sectional Area: {cross_sectional_area:.2f} m²")
print(f"Average Velocity: {average_velocity:.2f} m/s")
print(f"Flow Rate: {flow_rate:.2f} m³/s")

# Interpolating polynomials for H and U
H_spline = CubicSpline(y, H)
U_spline = CubicSpline(y, U)

# Generate 100 values between 0 and 10
y_interp = np.linspace(0, 10, 100)
H_interp = H_spline(y_interp)
U_interp = U_spline(y_interp)

# Plotting the interpolation
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(y, H, 'o', label='Original H')
plt.plot(y_interp, H_interp, '-', label='Interpolated H')
plt.xlabel('y (m)')
plt.ylabel('H (m)')
plt.title('Depth (H) Interpolation')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(y, U, 'o', label='Original U')
plt.plot(y_interp,U_interp,'-',label='Interpolated U')
plt.xlabel('y (m)')
plt.ylabel('U (m/s)')
plt.title('Velocity (U) Interpolation')
plt.legend()

plt.show()

# (a) Average Depth using interpolated values
average_depth_interp = np.trapz(H_interp, y_interp) / (y_interp[-1] - y_interp[0])

# (b) Cross-Sectional Area using interpolated values
cross_sectional_area_interp = np.trapz(H_interp, y_interp)

# (c) Average Velocity using interpolated values
average_velocity_interp = np.trapz(U_interp, y_interp) / (y_interp[-1] - y_interp[0])

# (d) Flow Rate using interpolated values
flow_rate_interp = cross_sectional_area_interp * average_velocity_interp

print(f"Average Depth (Interpolated): {average_depth_interp:.2f} m")
print(f"Cross-Sectional Area (Interpolated): {cross_sectional_area_interp:.2f} m²")
print(f"Average Velocity (Interpolated): {average_velocity_interp:.2f} m/s")
print(f"Flow Rate (Interpolated): {flow_rate_interp:.2f} m³/s")