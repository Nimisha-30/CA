# -*- coding: utf-8 -*-
"""PS6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_bpJvohL2uNZ_YoUMEmfk_3wicl31b2y
"""



import pandas as pd
from datetime import datetime

dateparse = lambda x: datetime.strptime(x, '%B-%Y')
data = {}
data['Axis'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Axis.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Federal'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Federal.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Baroda'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Baroda.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['SBI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/SBI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['HDFC'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/HDFC.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['ICICI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/ICICI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['PNB'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/PNB.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['KotakMahindra'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/KotakMahindra.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')

"""## Probability Stock Goes Up or Down


"""

import numpy as np

upPercent = {}
downPercent = {}
upProb = {}
downProb = {}

for ticker in data:
    n = len(data[ticker]['Close Price'])
    upPercent[ticker] = np.mean((data[ticker]['High Price'] - data[ticker]['Open Price']) / data[ticker]['Open Price'])
    downPercent[ticker] = np.mean((data[ticker]['Open Price'] - data[ticker]['Low Price']) / data[ticker]['Open Price'])
    upProb[ticker] = 0
    downProb[ticker] = 0
    for i in range(n - 1):
        if data[ticker]['Close Price'].iloc[i + 1] > data[ticker]['Close Price'].iloc[i]:
            upProb[ticker] += 1
        else:
            downProb[ticker] += 1
    upProb[ticker] /= n - 1
    downProb[ticker] /= n - 1

print("Average percentage of going up:")
print(upPercent)
print("Average percentage of going down:")
print(downPercent)
print("Probability of going up:")
print(upProb)
print("Probability og goin down:")
print(downProb)

"""## Risk and Return"""

for ticker in data:
    data[ticker]['RoR'] = (data[ticker]['Close Price'] - data[ticker]['Open Price']) / data[ticker]['Open Price']

mu = np.array([data[ticker]['RoR'].mean() for ticker in data])
sigma = np.array([data[ticker]['RoR'].std() for ticker in data])

print("Returns:", mu)
print("Risk:", sigma)

"""## Correlation"""

correlation = np.corrcoef([data[ticker]['RoR'] for ticker in data])

print("Correlation Matrix:")
print(pd.DataFrame(correlation, columns = data.keys(), index = data.keys()))

"""## Minimum  Variance Portfolio"""

from scipy.optimize import minimize
import math

def getMVP(mu, cov):
    u = np.ones(len(mu))
    num = np.matmul(u, np.linalg.inv(cov))
    optimalWeights = num / np.matmul(num, u.transpose())
    print(optimalWeights)

def weightConstraint(weights):
    return np.sum(weights) - 1.0

def minObjectiveFun(weights, covMatrix):
    return np.dot(weights, np.dot(covMatrix, weights))

def minVar(mu, cov):
    print("Minimizing Risk")
    initialWeights = np.ones(len(mu)) / len(mu)
    constraints = ({'type': 'eq', 'fun': weightConstraint})
    result = minimize(minObjectiveFun, initialWeights, args = (cov), method = 'SLSQP', constraints = constraints)
    optimalWeights = result.x

    print("Optimal Weights:", result.x)
    getMVP(mu, cov)
    print("Portfolio Risk:", math.sqrt(result.fun))
    print('Portfolio Expected Return:', np.dot(optimalWeights, mu))

    return optimalWeights, math.sqrt(result.fun), np.dot(optimalWeights, mu)

covMatrix = np.array(np.cov([data[ticker]['RoR'] for ticker in data]))
mvp = minVar(mu, covMatrix)

import matplotlib.pyplot as plt
import numpy as np
import math

# SBI
# mu = 0.11; sigma = 0.265

# ICICI
# mu = 0.15; sigma = 0.231

# roh = 0.805

sigma = []
mu = []

weights = np.linspace(0, 1)
for w in weights:
    mu.append(w * 0.11 + (1 - w) * 0.15)
    sigma.append(math.sqrt(w ** 2 * 0.265 ** 2 + (1 - w) ** 2 * 0.231 ** 2 + 2 * w * (1 - w) * 0.805 * 0.265 * 0.231))

plt.plot(sigma, mu)
plt.scatter(0.265, 0.11, label = 'SBI')
plt.scatter(0.231, 0.15, label = 'ICICI')
plt.grid(True)
plt.title('Risk-Return Graph')
plt.xlabel('Risk')
plt.ylabel('Expected Return')
plt.legend()
plt.show()

"""## Regression Line between Open and LTP"""

from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

fig, axes = plt.subplots(4, 2, figsize = (25, 50))
axes = axes.ravel()

for i, ticker in enumerate(data):
    X = data[ticker]['Open Price'].values.reshape(-1, 1)
    Y = data[ticker]['Close Price'].values.reshape(-1, 1)
    reg = LinearRegression().fit(X, Y)
    axes[i].scatter(X, Y, label = 'Actual', s = 2)
    axes[i].plot(X, reg.predict(X), color = 'red', label = 'Predicted')
    axes[i].set_title(ticker)
    axes[i].set_xlabel('Open')
    axes[i].set_ylabel('LTP')
    axes[i].legend()

plt.tight_layout()
plt.show()

"""## Beta Values"""

def covariance(x, y):
    n = len(x)
    meanX = np.mean(x)
    meanY = np.mean(y)
    total = 0
    for i in range(n):
        total += (x[i] - meanX) * (y[i] - meanY)
    return total / n

beta = {}
betaV = 0

for i, ticker in enumerate(data):
    X = list(data[ticker]['RoR'])
    Y = list(data['ICICI']['RoR'])

    beta[ticker] = covariance(X, Y) / np.var(Y)
    betaV += mvp[0][i] * beta[ticker]

print("Beta Values:")
print(beta)
print("Beta Value of MVP:", betaV)

"""## Risk-Return Graph"""

plt.scatter(mvp[1], mvp[2], label = 'Min Risk', marker = 'o')
for i, ticker in enumerate(data):
    plt.scatter(sigma[i], mu[i], label = ticker, marker = 'x')
plt.grid(True)
plt.xlabel('Risk')
plt.ylabel('Return')
plt.legend(bbox_to_anchor=(1.1, 1.05))
plt.title('Risk-Return Graph')
plt.show()

"""## Expected Return using CAPM"""

riskFreeRate = 0.06

expReturn = riskFreeRate + betaV * (np.mean(data['ICICI']['RoR']) - riskFreeRate)
print("Expected Return of the Portfolio: ", expReturn * 100, "%", sep = '')