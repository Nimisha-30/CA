# -*- coding: utf-8 -*-
"""PS1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JmllDZnmsLijthJEZLeUTdOYi16udDsI
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import pandas as pd

"""# Problem 1"""

def plot_histogram(array, bins=10):
    plt.figure(figsize=(8, 4))
    plt.hist(array, bins)
    plt.title('Histogram')
    plt.xlabel('Value')
    plt.ylabel('Frequency')
    plt.show()

def plot_frequency_polygon(array, bins=10):
    counts, bin_edges=np.histogram(array, bins=bins)
    bin_midpoints=0.5*(bin_edges[1:]+bin_edges[:-1])
    plt.figure(figsize=(8, 4))
    plt.plot(bin_midpoints, counts, marker='o', linestyle='-')
    plt.title('Frequency Polygon')
    plt.xlabel('Value')
    plt.ylabel('Frequency')
    plt.show()

"""## Uniform Distribution"""

uniform500=np.random.uniform(-1, 1, 500)
#print(len(uniform500))
plot_histogram(uniform500, 50)
print()
plot_frequency_polygon(uniform500, 50)

"""## Exponential Distribution"""

exponential500=np.random.exponential(size=500)
plot_histogram(exponential500, 50)
print()
plot_frequency_polygon(exponential500, 50)

"""## Weibull Distribution"""

weibull500=np.random.weibull(2, 500)
plot_histogram(weibull500, 50)
print()
plot_frequency_polygon(weibull500, 50)

"""## Triangular Distribution"""

triangular500=[]
for i in range(500):
    triangular500.append(random.triangular(0, 50, 5))
plot_histogram(triangular500, 50)
print()
plot_frequency_polygon(triangular500, 50)

h=plt.hist(np.random.triangular(-1, 0, 1, 500), bins=50, density=True)
plt.show()

traingular500=np.random.triangular(-1, 0, 1, 500)
plot_histogram(traingular500, 50)
print()
plot_frequency_polygon(traingular500, 50)

"""# Problem 2"""

def estimate_pi(INTERVAL):
    circle_points=0
    square_points=0
    for i in range(INTERVAL**2):
        x=random.uniform(-1, 1)
        y=random.uniform(-1, 1)
        if x**2+y**2<=1:
            circle_points+=1
        square_points+=1
        pi=4*circle_points/square_points
    print("Final estimation of PI:", pi)

estimate_pi(500)

estimate_pi(1000)

estimate_pi(10000)

estimate_pi(100000)

"""For the above randomly generated distributions:"""

def estimate_using_dist(arr):
    # n=len(arr)/2
    for i in range(len(arr)):
        x_arr=arr[:250]
        y_arr=arr[250:]
    # print(len(x_arr))
    # print(len(y_arr))
    circle_points=0
    square_points=0
    for i in range(len(x_arr)):
        if x_arr[i]**2+y_arr[i]**2<=1:
            circle_points+=1
        square_points+=1
        pi=4*circle_points/square_points
    print("Final estimation of PI:", pi)

estimate_using_dist(uniform500)

estimate_using_dist(exponential500)

estimate_using_dist(weibull500)

estimate_using_dist(triangular500)

"""# Problem 3"""

def f(x):
  return np.sin(np.pi*np.cos(np.cos(3*x)))**2*np.cos(x)**2

def evaluate_integration(f, a, b, N):
    plt_vals=[]
    for i in range(N):
        arr=np.zeros(N)
        for i in range(len(arr)):
            arr[i]=random.uniform(a, b)
        integral=0
        for i in arr:
            integral+=f(i)
        result=(b-a)/N*integral
        plt_vals.append(result)
    plt.figure(figsize=(20, 10))
    plt.title("Distributions of area calculated")
    plt.plot(plt_vals, linestyle='solid')
    plt.xlabel("Areas")
    plt.show()

evaluate_integration(f, 0, np.pi, 500)

"""# Problem 4

https://virtuaq.com/blog/2017-11-23-basics-of-queuing-theory
"""

def fifo_simulation(arrival, service, n=1000):
    arrival=np.cumsum(arrival)
    service_start=np.zeros(n)
    wait_time=np.zeros(n)
    for i in range(n):
        service_start[i] = max(arrival[i], service_start[i-1]+service[i-1])
        wait_time[i] = service_start[i] - arrival[i]
    queue = np.zeros(n)
    for i in range(1, n):
        queue[i] = np.sum((arrival[:i] <= service_start[i]) & (service_start[:i] > arrival[i]))
    avg_wait = np.mean(wait_time)
    avg_length = np.mean(queue)
    avg_wait_service = np.mean(wait_time+service)
    return avg_wait, avg_length, avg_wait_service

"""Poisson arrival with mean 3 sec and Exponential service time with mean 4 sec:"""

np.random.seed(42)
poisson_arrival = np.random.exponential(3, 1000)
exp_service1 = np.random.exponential(4, 1000)
poisson_avg_wait, poisson_avg_length, poisson_avg_wait_service = fifo_simulation(poisson_arrival, exp_service1)
print(f"Poisson Arrival with Exponential Service:\n  Average Waiting Time in Queue: {poisson_avg_wait}\n  Average Queue Length: {poisson_avg_length}\n  Average Waiting Time in System: {poisson_avg_wait_service}")

"""Uniform arrival with mean 3 sec and Exponential service time with mean 4 sec:"""

np.random.seed(42)
uniform_arrival = np.random.uniform(0, 5, 1000)
exp_service2 = np.random.exponential(4, 1000)
uniform_avg_wait, uniform_avg_length, uniform_avg_wait_service = fifo_simulation(uniform_arrival, exp_service2)
print(f"Uniform Arrival with Exponential Service:\n  Average Waiting Time in Queue: {uniform_avg_wait}\n  Average Queue Length: {uniform_avg_length}\n  Average Waiting Time in System: {uniform_avg_wait_service}")

"""# Problem 5"""

periods = 10
prodcap_regtime = [100, 40, 90, 60, 70, 60, 50, 40, 50, 40]
prodcap_overtime = [50, 60, 80, 50, 50, 70, 80, 50, 50, 50]
prodcap_subcont = [30, 80, 70, 20, 100, 80, 40, 40, 50, 30]
demand_intervals = [(140, 200), (190, 210), (140, 160), (195, 215), (200, 220),
                    (155, 175), (125, 135), (120, 140), (110, 130), (90, 105)]
prodcost_regular = 4
prodcost_overtime = 6
prodcost_subcont = 7
holding_cost = 0.5

np.random.seed(0)
demands = [np.random.randint(low, high + 1, 100) for (low, high) in demand_intervals]
average_demand = [int(np.mean(demand)) for demand in demands]
print(average_demand)

def calculate_cost(demand, regular, overtime, subcontracting):
    total_cost = 0
    production = 0
    if demand <= regular:
        total_cost = demand * prodcost_regular
        production = demand
    elif demand <= regular + overtime:
        total_cost = regular * prodcost_regular + (demand - regular) * prodcost_overtime
        production = demand
    else:
        total_cost = regular * prodcost_regular + overtime * prodcost_overtime + (demand - regular - overtime) * prodcost_subcont
        production = demand
    return total_cost, production

total_costs = []
productions = []
for i in range(periods):
    cost, production = calculate_cost(average_demand[i], prodcap_regtime[i], prodcap_overtime[i], prodcap_subcont[i])
    total_costs.append(cost)
    productions.append(production)
total_production_cost = sum(total_costs)
for i in range(periods):
    print(f"Period {i+1}: Average Demand = {average_demand[i]}, Total Cost = {total_costs[i]}, Production = {productions[i]}")
print(f"Total Production Cost over {periods} periods: Rs {total_production_cost:.2f}")

"""# Problem 7"""

num_days = 1000
cost_price = 0.30
selling_price = 0.45
scrap_price = 0.05
news_probabilities = [0.35, 0.45, 0.20]
news_cumulative_prob = np.cumsum(news_probabilities)

news_type_ranges = [(1, 35), (36, 80), (81, 100)]

demand_ranges = {
    "Demand" : [40,50,60,70,80,90,100],
    "Good": [(1, 3), (4, 8), (9, 23), (24, 43), (44, 78), (79, 93), (94, 100)],
    "Fair": [(1, 10), (11, 28), (29, 68), (69, 88), (89, 96), (97, 100), None],
    "Poor": [(1, 44), (45, 66), (67, 82), (83, 94), (95, 100), None, None]
}

df2 = pd.DataFrame(demand_ranges)
df2.head()

np.random.seed(42)
news_type_random_numbers = np.random.uniform(0, 100, num_days)

news_types = []

for num in news_type_random_numbers:
    if num <= 35:
        news_types.append("Good")
    elif num <= 80:
        news_types.append("Fair")
    else:
        news_types.append("Poor")

print(len(news_types))

demand_values = []

for news_type in news_types:
    if news_type == "Good":
        demand_random_number = np.random.exponential(50)
    elif news_type == "Fair":
        demand_random_number = np.random.normal(50, 10)
    else:
        demand_random_number = np.random.poisson(50)

    for i, demand_range in enumerate(demand_ranges[news_type]):
        if demand_range is not None:
            low, high = demand_range
            if low <= demand_random_number <= high:
                demand_values.append(demand_ranges["Demand"][i])
                break

print(len(demand_values))

revenues = []
losses = []
loss_by_excess_demand = []
salvages = []
profits = []
bought_newspapers = 100

for demand in demand_values:
  sold_newspapers = min(demand, bought_newspapers)
  unsold_newspapers = bought_newspapers - sold_newspapers

  revenue = sold_newspapers * selling_price
  loss = (demand - bought_newspapers) * (selling_price - cost_price) if demand > bought_newspapers else 0
  salvage = unsold_newspapers * scrap_price
  profit = revenue + salvage - (bought_newspapers * cost_price)

  revenues.append(revenue)
  losses.append(loss)
  salvages.append(salvage)
  profits.append(profit)
  daily_revenue = selling_price * demand
  revenues.append(daily_revenue)

average_profit = np.mean(profits)

print("Daily Metrics Over 1000 Days:")
print(f"Total Revenue: {sum(revenues):.2f}")
print(f"Total Loss of Profit from Excess Demand: {sum(losses):.2f}")
print(f"Total Salvage from Unsold Papers: {sum(salvages):.2f}")
print(f"Total Profit: {sum(profits):.2f}")
print(f"Average Daily Profit: {average_profit:.2f}")